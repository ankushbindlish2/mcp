parameters:
- name: ServerName
  type: string
  default: ''
- name: PublishTarget
  type: string
  default: none
  values: [none, internal, public ]
- name: RunLiveTests
  type: boolean
  default: false
- name: IncludeNative
  type: boolean
  default: false
- name: PackageDocker
  type: boolean
  default: false
- name: PackageVSIX
  type: boolean
  default: false
- name: IsTestPipeline
  type: boolean
  default: false
  # Test pipelines (e.g. Template.Mcp.Server) can release to public feeds, but they always use prerelease tags and automatically close their version bump PRs
  # This allows us to run them multiple times from the same commit without hitting github release tag or package deployment conflicts

resources:
  repositories:
  - repository: azure-sdk-build-tools
    type: git
    name: internal/azure-sdk-build-tools
    ref: refs/tags/azure-sdk-build-tools_20250808.1

extends:
  template: /eng/pipelines/templates/1es-redirect.yml
  parameters:
    autoBaseline: false
    stages:
    - stage: CheckTokens
      pool:
        name: $(LINUXPOOL)
        image: $(LINUXVMIMAGE)
        os: linux
      variables:
      - template: /eng/pipelines/templates/variables/image.yml
      - template: /eng/pipelines/templates/variables/globals.yml
      jobs:
      - job: CheckTokens
        steps:
        - ${{ each i in split('1,2,3', ',') }}:
          - task: AzurePowershell@5
            displayName: "Azure Powershell ${{ i }}"
            env:
              SYSTEM_ACCESSTOKEN: $(System.AccessToken)
            inputs:
              azureSubscription: azure-sdk-tests-public
              azurePowerShellVersion: 'LatestVersion'
              scriptType: InlineScript
              Inline: |
                function Get-TokenTimestamp {
                  param (
                    [int]$unixTime
                  )
                  return [DateTimeOffset]::FromUnixTimeSeconds($unixTime)
                }

                function Get-AzureToken {
                  $token = Get-AzAccessToken -AsSecureString
                  $similar = $token | Select-Object -Property * -ExcludeProperty Token
                  Write-Host "Current Time: $(Get-Date)`n"
                  Write-Host "Azure Token Info: `n$($similar | ConvertTo-Json)`n"

                  # Convert SecureString to plain string
                  $bstr = [Runtime.InteropServices.Marshal]::SecureStringToCoTaskMemUnicode($token.Token)
                  $tokenString = [Runtime.InteropServices.Marshal]::PtrToStringAuto($bstr)
                  [Runtime.InteropServices.Marshal]::ZeroFreeCoTaskMemUnicode($bstr)
                  return $tokenString
                }

                function Check-AccessToken {
                  param (
                      [string]$token,
                      [string]$tokenName
                  )

                  Write-Host "`nChecking $tokenName..."
                  $token
                  $parts = $token.Split('.')
                  if ($parts.Length -ne 3) {
                    Write-Host "Invalid token format for $tokenName. Expected 3 parts but got $($parts.Length)."
                    return
                  }

                  $base64 = $parts[1]
                  Write-Host "Token payload part: $base64"

                  $paddedBase64 = $base64.PadRight($base64.Length + (4 - $base64.Length % 4) % 4, '=')
                  $decodedBytes = [System.Convert]::FromBase64String($paddedBase64)
                  $decodedString = [System.Text.Encoding]::UTF8.GetString($decodedBytes)
                  $decodedToken = $decodedString | ConvertFrom-Json
                  
                  $issueTime = Get-TokenTimestamp $decodedToken.iat ?? $decodedToken.nbf
                  $expirationTime = Get-TokenTimestamp $decodedToken.exp
                  [DateTimeOffset]$now = Get-Date
                  $remaining = $expirationTime - $now
                  $age = $now - $issueTime

                  Write-Host "$tokenName`:"
                  Write-Host "Token Issued: $issueTime"
                  Write-Host "Token Expires: $expirationTime"
                  Write-Host "Token Age: $($age.ToString("hh\:mm\:ss"))"
                  Write-Host "Remaining: $($remaining.ToString("hh\:mm\:ss"))"
                }

                # Inspect the Access token for expiration time and subject
                Check-AccessToken -Token $env:SYSTEM_ACCESSTOKEN -TokenName "SYSTEM_ACCESSTOKEN"

                # Get an Azure PowershellToken and inspect it as well
                Write-Host "`nGetting Azure Powershell Token..."
                Get-AzureToken | Out-Null

                Write-Host "Waiting 3 minutes..."
                Start-Sleep -Seconds 180

                Write-Host "`nGetting Azure Powershell Token..."
                Get-AzureToken | Out-Null

                Write-Host "Waiting 3 minutes..."
                Start-Sleep -Seconds 180

                Write-Host "`nGetting Azure Powershell Token..."
                Get-AzureToken | Out-Null
              pwsh: true
              workingDirectory: $(Build.SourcesDirectory)

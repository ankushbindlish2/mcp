parameters:
- name: ServerName
  type: string
  default: ''
- name: PublishTarget
  type: string
  default: none
  values: [none, internal, public ]
- name: RunLiveTests
  type: boolean
  default: false
- name: IncludeNative
  type: boolean
  default: false
- name: PackageDocker
  type: boolean
  default: false
- name: PackageVSIX
  type: boolean
  default: false
- name: IsTestPipeline
  type: boolean
  default: false
  # Test pipelines (e.g. Template.Mcp.Server) can release to public feeds, but they always use prerelease tags and automatically close their version bump PRs
  # This allows us to run them multiple times from the same commit without hitting github release tag or package deployment conflicts

resources:
  repositories:
  - repository: azure-sdk-build-tools
    type: git
    name: internal/azure-sdk-build-tools
    ref: refs/tags/azure-sdk-build-tools_20250808.1

extends:
  template: /eng/pipelines/templates/1es-redirect.yml
  parameters:
    autoBaseline: false
    stages:
    - stage: CheckTokens
      pool:
        name: $(LINUXPOOL)
        image: $(LINUXVMIMAGE)
        os: linux
      variables:
      - template: /eng/pipelines/templates/variables/image.yml
      - template: /eng/pipelines/templates/variables/globals.yml
      jobs:
      - job: CheckTokens
        displayName: "Check Token Validity Over Time"
        timeoutInMinutes: 240
        steps:
        - task: UseDotNet@2
          displayName: "Use .NET SDK from global.json"
          retryCountOnTaskFailure: 3
          inputs:
            useGlobalJson: true

        - task: AzurePowershell@5
          displayName: "Long running token test"
          timeoutInMinutes: 240
          env:
            SYSTEM_ACCESSTOKEN: $(System.AccessToken)
          inputs:
            azureSubscription: azure-sdk-tests-public
            azurePowerShellVersion: 'LatestVersion'
            scriptType: InlineScript
            Inline: |
              $env:AZURE_TOKEN_CREDENTIALS = 'AzurePowerShellCredential'

              $sequentialErrors = 0
              while ($true) {
                try {
                  Write-Host "Acquiring new tokens..."
                  $env:STORAGE_TOKEN = Get-AzAccessToken -ResourceUri 'https://storage.azure.com/' -AsSecureString | Select-Object -ExpandProperty Token | ConvertFrom-SecureString -AsPlainText

                  Write-Host "Checking pipeline token..."
                  dotnet run --project ./src/TokenDump.csproj -- env:SYSTEM_ACCESSTOKEN
                  Write-Host ""

                  Write-Host "Checking storage token..."
                  dotnet run --project ./src/TokenDump.csproj -- env:STORAGE_TOKEN
                  Write-Host ""

                  $uri = "$(System.CollectionUri)$(System.TeamProject)/_apis?api-version=6.0"
                  Write-Host "Testing pipeline token validity by calling Azure DevOps REST API:"
                  Write-Host "  $uri"
                  $pipelineResponse = Invoke-WebRequest -Uri $uri -Headers @{ "Authorization" = "Bearer $env:SYSTEM_ACCESSTOKEN" } -SkipHttpErrorCheck -MaximumRedirection 0
                  Write-Host "Status Code: $($pipelineResponse.StatusCode)"

                  Write-Host "Testing graph token validity by calling Azure AD Graph..."
                  $storageResponse = Invoke-WebRequest -Uri "https://mcp18b2df15.blob.core.windows.net/?comp=list" -Headers @{ "Authorization" = "Bearer $env:STORAGE_TOKEN"; "x-ms-version" = "2025-11-05" } -SkipHttpErrorCheck
                  Write-Host "Status Code: $($storageResponse.StatusCode)"

                  if($pipelineResponse.StatusCode -ne 200 -or $storageResponse.StatusCode -ne 200) {
                    Write-Host "`nPipeline Response:"
                    $pipelineResponse.RawContent | Out-Host
                    Write-Host "`nStorage Response:"
                    $storageResponse.RawContent | Out-Host

                    $sequentialErrors++
                    throw "One or more token tests failed."
                  }

                  $sequentialErrors = 0
                  Write-Host "Both token tests succeeded."
                  Write-Host "Sleeping for 5 minutes..."
                  Start-Sleep -Seconds 300
                } catch {
                  $sequentialErrors++
                  Write-Host "Error: $_"
                  Write-Host "Sequential errors: $sequentialErrors"
                  if ($sequentialErrors -ge 3) {
                    Write-Host "Failed multiple times. Exiting loop."
                    break
                  }
                  Write-Host "Sleeping for 10 seconds before retrying..."
                  Start-Sleep -Seconds 10
                }
              }
            pwsh: true
            workingDirectory: $(Build.SourcesDirectory)
